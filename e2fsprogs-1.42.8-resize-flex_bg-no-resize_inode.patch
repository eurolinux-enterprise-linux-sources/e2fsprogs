commit f026f1a37061a021f7188c9e45d0fbff1bde9e60
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sun Mar 31 13:24:39 2013 -0400

    resize2fs: fix off-line resize of file systems with flex_bg && !resize_inode
    
    When doing an off-line resize2fs of an initially very small file
    system, it's possible to run out of reserved gdt blocks (which are
    reserved via the resize inode).  Once we run out, we need to move the
    allocation bitmaps and inode table out of the way to grow the gdt
    blocks.  Unfortunately, when moving these metadata blocks, it was
    possible that a block that had been just been newly allocated for a
    new block group could also get allocated for a metadata block for an
    existing block group that was being moved.
    
    To prevent this, after we grow the gdt blocks and allocate the
    metadata blocks for the new block groups, make sure all of these
    blocks are marked as reserved.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Reported-by: John Jolly <john.jolly@gmail.com>

Index: e2fsprogs-1.41.12/resize/resize2fs.c
===================================================================
--- e2fsprogs-1.41.12.orig/resize/resize2fs.c
+++ e2fsprogs-1.41.12/resize/resize2fs.c
@@ -50,6 +50,8 @@ static errcode_t move_itables(ext2_resiz
 static errcode_t fix_resize_inode(ext2_filsys fs);
 static errcode_t ext2fs_calculate_summary_stats(ext2_filsys fs);
 static errcode_t fix_sb_journal_backup(ext2_filsys fs);
+static errcode_t mark_table_blocks(ext2_filsys fs,
+				   ext2fs_block_bitmap bmap);
 
 /*
  * Some helper CPP macros
@@ -287,9 +289,6 @@ static void free_gdp_blocks(ext2_filsys 
 /*
  * This routine is shared by the online and offline resize routines.
  * All of the information which is adjusted in memory is done here.
- *
- * The reserve_blocks parameter is only needed when shrinking the
- * filesystem.
  */
 errcode_t adjust_fs_info(ext2_filsys fs, ext2_filsys old_fs,
 			 ext2fs_block_bitmap reserve_blocks, blk_t new_size)
@@ -384,12 +383,22 @@ retry:
 	real_end = ((EXT2_BLOCKS_PER_GROUP(fs->super)
 		     * fs->group_desc_count)) - 1 +
 			     fs->super->s_first_data_block;
-	retval = ext2fs_resize_block_bitmap(fs->super->s_blocks_count-1,
+	retval = ext2fs_resize_block_bitmap(new_size - 1,
 					    real_end, fs->block_map);
 
 	if (retval) goto errout;
 
 	/*
+	 * If we are growing the file system, also grow the size of
+	 * the reserve_blocks bitmap
+	 */
+	if (reserve_blocks && new_size > ext2fs_blocks_count(old_fs->super)) {
+		retval = ext2fs_resize_block_bitmap(new_size - 1,
+						    real_end, reserve_blocks);
+		if (retval) goto errout;
+	}
+
+	/*
 	 * Reallocate the group descriptors as necessary.
 	 */
 	if (old_fs->desc_blocks != fs->desc_blocks) {
@@ -489,6 +498,15 @@ retry:
 	else
 		old_desc_blocks = fs->desc_blocks +
 			fs->super->s_reserved_gdt_blocks;
+
+	/*
+	 * If we changed the number of block_group descriptor blocks,
+	 * we need to make sure they are all marked as reserved in the
+	 * file systems's block allocation map.
+	 */
+	for (i = 0; i < old_fs->group_desc_count; i++)
+		ext2fs_reserve_super_and_bgd(fs, i, fs->block_map);
+
 	for (i = old_fs->group_desc_count;
 	     i < fs->group_desc_count; i++) {
 		memset(&fs->group_desc[i], 0,
@@ -557,6 +575,17 @@ retry:
 	}
 	retval = 0;
 
+	/*
+	 * Mark all of the metadata blocks as reserved so they won't
+	 * get allocated by the call to ext2fs_allocate_group_table()
+	 * in blocks_to_move(), where we allocate new blocks to
+	 * replace those allocation bitmap and inode table blocks
+	 * which have to get relocated to make space for an increased
+	 * number of the block group descriptors.
+	 */
+	if (reserve_blocks)
+		mark_table_blocks(fs, reserve_blocks);
+
 errout:
 	return (retval);
 }
@@ -686,6 +715,7 @@ static errcode_t mark_table_blocks(ext2_
 	blk_t			b;
 	unsigned int		j;
 	dgrp_t			i;
+	blk64_t			blk;
 	unsigned long		meta_bg_size;
 	unsigned int		old_desc_blocks;
 
@@ -701,22 +731,23 @@ static errcode_t mark_table_blocks(ext2_
 		/*
 		 * Mark the blocks used for the inode table
 		 */
-		for (j = 0, b = fs->group_desc[i].bg_inode_table;
-		     j < (unsigned int) fs->inode_blocks_per_group;
-		     j++, b++)
-			ext2fs_mark_block_bitmap(bmap, b);
-
+		blk = ext2fs_inode_table_loc(fs, i);
+		if (blk)
+			ext2fs_mark_block_bitmap_range(bmap, blk,
+						fs->inode_blocks_per_group);
 		/*
 		 * Mark block used for the block bitmap
 		 */
-		ext2fs_mark_block_bitmap(bmap,
-					 fs->group_desc[i].bg_block_bitmap);
+		blk = ext2fs_block_bitmap_loc(fs, i);
+		if (blk)
+			ext2fs_mark_block_bitmap(bmap, blk);
 
 		/*
 		 * Mark block used for the inode bitmap
 		 */
-		ext2fs_mark_block_bitmap(bmap,
-					 fs->group_desc[i].bg_inode_bitmap);
+		blk = ext2fs_inode_bitmap_loc(fs, i);
+		if (blk)
+			ext2fs_mark_block_bitmap(bmap, blk);
 	}
 	return 0;
 }
