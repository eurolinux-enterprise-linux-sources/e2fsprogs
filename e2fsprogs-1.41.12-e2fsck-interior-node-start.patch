commit 789bd401c3bce85d3c2ae4504ca62509aa0a8b88
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Dec 20 14:05:01 2012 -0500

    e2fsck: fix incorrect interior node logical start values
    
    An index node's logical start (ei_block) should
    match the logical start of the first node (index
    or leaf) below it.  If we find a node whose start
    does not match its parent, fix all of its parents
    accordingly.
    
    If it finds such a problem, we'll see:
    
    Pass 1: Checking inodes, blocks, and sizes
    Interior extent node level 0 of inode 274258:
    Logical start 3666 does not match logical start 4093 at next level.  Fix<y>?
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

commit eacf6a0878a92836231ee69813cb8764d21140f9
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Dec 20 18:27:33 2012 -0500

    libext2fs: ext2fs_extents_fix_parents() should not modify the handle location
    
    Previously, ext2fs_extent_fix_parents() would only avoid modifying the
    cursor location associated with the extent handle the cursor was
    pointed at a leaf node in the extent tree.  This is because it saved
    the starting logical block number of the current extent, but not the
    "level" of the extent (where level 0 is the leaf node, level 1 is the
    interior node which points at blocks containing leaf nodes, etc.)
    
    Fix ext2fs_extent_fix_parents() so it is guaranteed to not change the
    current extent in the handle even if the current extent is not at the
    bottom of the tree.
    
    Also add a fix_extent command to the tst_extents program to make it
    easier to test this function.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

commit 29e8e74e02ae742874c8c37012da1e04a858eb2f
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Dec 20 18:37:01 2012 -0500

    e2fsck: make sure the extent tree is consistent after bogus node in the tree
    
    Commit 789bd401c3 ("e2fsck: fix incorrect interior node logical start
    values") surfaced a bug where if e2fsck finds and removed an invalid
    node in the extent tree, i.e.:
    
    Inode 12 has an invalid extent node (blk 22, lblk 0)
    Clear? yes
    
    It was possible for starting logical blocks found in the interior
    nodes of the extent tree.  Commit 789bd401c3 added the ability for
    e2fsck to discover this problem, which resulted in the test
    f_extent_bad_node to fail when the second pass of e2fsck reported the
    following complaint:
    
    Interior extent node level 0 of inode 12:
    Logical start 0 does not match logical start 3 at next level.  Fix? yes
    
    This patch fixes this by adding a call to ext2fs_extent_fix_parents()
    after deleting the bogus node in the extent tree.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

commit b4944f654cac5f70edd80d12e59bf1212047cb5d
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Dec 20 21:48:08 2012 -0500

    tests: add test of an incorrect interior node in an extent tree
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>


Index: e2fsprogs-1.41.12/e2fsck/pass1.c
===================================================================
--- e2fsprogs-1.41.12.orig/e2fsck/pass1.c
+++ e2fsprogs-1.41.12/e2fsck/pass1.c
@@ -1707,7 +1707,7 @@ static void scan_extent_node(e2fsck_t ct
 			problem = PR_1_EXTENT_ENDS_BEYOND;
 
 		if (problem) {
-		report_problem:
+report_problem:
 			pctx->blk = extent.e_pblk;
 			pctx->blk2 = extent.e_lblk;
 			pctx->num = extent.e_len;
@@ -1719,6 +1719,7 @@ static void scan_extent_node(e2fsck_t ct
 					pctx->str = "ext2fs_extent_delete";
 					return;
 				}
+				ext2fs_extent_fix_parents(ehandle);
 				pctx->errcode = ext2fs_extent_get(ehandle,
 								  EXT2_EXTENT_CURRENT,
 								  &extent);
@@ -1732,7 +1733,10 @@ static void scan_extent_node(e2fsck_t ct
 		}
 
 		if (!is_leaf) {
+			blk64_t lblk;
+
 			blk = extent.e_pblk;
+			lblk = extent.e_lblk;
 			pctx->errcode = ext2fs_extent_get(ehandle,
 						  EXT2_EXTENT_DOWN, &extent);
 			if (pctx->errcode) {
@@ -1742,6 +1746,18 @@ static void scan_extent_node(e2fsck_t ct
 					goto report_problem;
 				return;
 			}
+			/* The next extent should match this index's logical start */
+			if (extent.e_lblk != lblk) {
+				struct ext2_extent_info info;
+
+				ext2fs_extent_get_info(ehandle, &info);
+				pctx->blk = lblk;
+				pctx->blk2 = extent.e_lblk;
+				pctx->num = info.curr_level - 1;
+				problem = PR_1_EXTENT_INDEX_START_INVALID;
+				if (fix_problem(ctx, problem, pctx))
+					ext2fs_extent_fix_parents(ehandle);
+			}
 			scan_extent_node(ctx, pctx, pb, extent.e_lblk, ehandle);
 			if (pctx->errcode)
 				return;
Index: e2fsprogs-1.41.12/e2fsck/problem.c
===================================================================
--- e2fsprogs-1.41.12.orig/e2fsck/problem.c
+++ e2fsprogs-1.41.12/e2fsck/problem.c
@@ -885,6 +885,14 @@ static struct e2fsck_problem problem_tab
 	  N_("@i %i has an invalid extent node (blk %b, lblk %c)\n"),
 	  PROMPT_CLEAR, 0 },
 
+	/*
+	 * Interior extent node logical offset doesn't match first node below it
+	 */
+	{ PR_1_EXTENT_INDEX_START_INVALID,
+	  N_("Interior @x node level %N of @i %i:\n"
+	     "Logical start %b does not match logical start %c at next level.  "),
+	  PROMPT_FIX, 0 },
+
 	/* Pass 1b errors */
 
 	/* Pass 1B: Rescan for duplicate/bad blocks */
Index: e2fsprogs-1.41.12/e2fsck/problem.h
===================================================================
--- e2fsprogs-1.41.12.orig/e2fsck/problem.h
+++ e2fsprogs-1.41.12/e2fsck/problem.h
@@ -579,6 +579,9 @@ struct problem_context {
 /* Couldn't clone file (error) */
 #define PR_1D_CLONE_ERROR	0x013008
 
+/* Index start doesn't match start of next extent down */
+#define PR_1_EXTENT_INDEX_START_INVALID	0x01006D
+
 /*
  * Pass 2 errors
  */
Index: e2fsprogs-1.41.12/lib/ext2fs/ext2fs.h
===================================================================
--- e2fsprogs-1.41.12.orig/lib/ext2fs/ext2fs.h
+++ e2fsprogs-1.41.12/lib/ext2fs/ext2fs.h
@@ -923,6 +923,7 @@ extern errcode_t ext2fs_extent_get_info(
 					struct ext2_extent_info *info);
 extern errcode_t ext2fs_extent_goto(ext2_extent_handle_t handle,
 				    blk64_t blk);
+extern errcode_t ext2fs_extent_fix_parents(ext2_extent_handle_t handle);
 
 /* fileio.c */
 extern errcode_t ext2fs_file_open2(ext2_filsys fs, ext2_ino_t ino,
Index: e2fsprogs-1.41.12/lib/ext2fs/extent.c
===================================================================
--- e2fsprogs-1.41.12.orig/lib/ext2fs/extent.c
+++ e2fsprogs-1.41.12/lib/ext2fs/extent.c
@@ -709,12 +709,14 @@ errcode_t ext2fs_extent_goto(ext2_extent
  * Safe to call for any position in node; if not at the first entry,
  * will  simply return.
  */
-static errcode_t ext2fs_extent_fix_parents(ext2_extent_handle_t handle)
+errcode_t ext2fs_extent_fix_parents(ext2_extent_handle_t handle)
 {
 	int				retval = 0;
+	int				orig_height;
 	blk64_t				start;
 	struct extent_path		*path;
 	struct ext2fs_extent		extent;
+	struct ext2_extent_info		info;
 
 	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
 
@@ -735,6 +737,10 @@ static errcode_t ext2fs_extent_fix_paren
 	/* modified node's start block */
 	start = extent.e_lblk;
 
+	if ((retval = ext2fs_extent_get_info(handle, &info)))
+		return retval;
+	orig_height = info.max_depth - info.curr_level;
+
 	/* traverse up until index not first, or startblk matches, or top */
 	while (handle->level > 0 &&
 	       (path->left == path->entries - 1)) {
@@ -753,7 +759,7 @@ static errcode_t ext2fs_extent_fix_paren
 	}
 
 	/* put handle back to where we started */
-	retval = ext2fs_extent_goto(handle, start);
+	retval = extent_goto(handle, orig_height, start);
 done:
 	return retval;
 }
Index: e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/expect.1
===================================================================
--- /dev/null
+++ e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/expect.1
@@ -0,0 +1,12 @@
+Pass 1: Checking inodes, blocks, and sizes
+Interior extent node level 0 of inode 12:
+Logical start 0 does not match logical start 2 at next level.  Fix? yes
+
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+
+test_filesys: ***** FILE SYSTEM WAS MODIFIED *****
+test_filesys: 12/16 files (0.0% non-contiguous), 29/100 blocks
+Exit status is 1
Index: e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/expect.2
===================================================================
--- /dev/null
+++ e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/expect.2
@@ -0,0 +1,7 @@
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 12/16 files (0.0% non-contiguous), 29/100 blocks
+Exit status is 0
Index: e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/name
===================================================================
--- /dev/null
+++ e2fsprogs-1.41.12/tests/f_extent_interior_start_lblk/name
@@ -0,0 +1 @@
+incorrect starting lblk in an interior node
