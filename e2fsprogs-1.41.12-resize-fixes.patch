
NOTE:
NOTE:  3 patches are concatenated below
NOTE:

commit 2ebaeb35dba540f5de578c848a5d1787d0ef2720
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Fri Dec 28 19:54:19 2012 -0500

    resize2fs: reserve fs metadata blocks first in blocks_to_move()
    
    This is the first commit to add support for off-line resizing using
    flex_bg without the assist of using the resize_inode to reserve gdt
    blocks.  This functionality has been broken up into separate commits
    which are hopefully obviously correct to make them easier to review
    for correctness.
    
    In this first step, we break up the for loop at the end of
    blocks_to_move() so that we first mark all of the metadata blocks
    which don't need to be moved in the reserve_blocks bitmap, and then
    try to allocate the metadata blocks are new or which need to moved
    second.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

Index: e2fsprogs-1.41.12/resize/resize2fs.c
===================================================================
--- e2fsprogs-1.41.12.orig/resize/resize2fs.c
+++ e2fsprogs-1.41.12/resize/resize2fs.c
@@ -899,6 +899,7 @@ static errcode_t blocks_to_move(ext2_res
 	 * gets interesting....
 	 */
 	meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
+	/* first reserve all of the existing fs meta blocks */
 	for (i = 0; i < max_groups; i++) {
 		has_super = ext2fs_bg_has_super(fs, i);
 		if (has_super)
@@ -924,11 +925,6 @@ static errcode_t blocks_to_move(ext2_res
 						  group_blk + has_super);
 		}
 
-		if (fs->group_desc[i].bg_inode_table &&
-		    fs->group_desc[i].bg_inode_bitmap &&
-		    fs->group_desc[i].bg_block_bitmap)
-			goto next_group;
-
 		/*
 		 * Reserve the existing meta blocks that we know
 		 * aren't to be moved.
@@ -945,9 +941,17 @@ static errcode_t blocks_to_move(ext2_res
 				ext2fs_mark_block_bitmap(rfs->reserve_blocks,
 							 blk);
 
+		group_blk += rfs->new_fs->super->s_blocks_per_group;
+	}
+
+	/* Allocate the missing data structures */
+	for (i = 0; i < max_groups; i++) {
+		if (ext2fs_inode_table_loc(fs, i) &&
+		    ext2fs_inode_bitmap_loc(fs, i) &&
+		    ext2fs_block_bitmap_loc(fs, i))
+			continue;
+
 		/*
-		 * Allocate the missing data structures
-		 *
 		 * XXX We have a problem with FLEX_BG and off-line
 		 * resizing where we are growing the size of the
 		 * filesystem.  ext2fs_allocate_group_table() will try
@@ -1002,7 +1006,7 @@ static errcode_t blocks_to_move(ext2_res
 		 * block relocation phase.
 		 */
 		if (FS_INODE_TB(fs, i) == FS_INODE_TB(old_fs, i))
-			goto next_group; /* inode table not moved */
+			continue; /* inode table not moved */
 
 		rfs->needed_blocks += fs->inode_blocks_per_group;
 
@@ -1028,8 +1032,6 @@ static errcode_t blocks_to_move(ext2_res
 		     j < fs->inode_blocks_per_group ; j++, blk++)
 			ext2fs_mark_block_bitmap(rfs->reserve_blocks, blk);
 
-	next_group:
-		group_blk += rfs->new_fs->super->s_blocks_per_group;
 	}
 	retval = 0;
 
commit 4b04fb30e01c7418331caa01ecf071bd55672f1a
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Dec 29 00:53:16 2012 -0500

    resize2fs: reserve all metadata blocks for flex_bg file systems
    
    For flex_bg file systems, if we need to relocate an allocation bitmap
    or inode table, we need to make sure that all metadata blocks have
    been reserved, lest we end up overwriting a metadata block belonging
    to a different block group.
    
    This change fixes the following test case:
    
    rm -f foo.img; touch foo.img
    truncate -s 32G foo.img
    mke2fs -F -t ext4 -E resize=12582912 foo.img
    e2fsck -f foo.img
    truncate -s 64G foo.img
    ./resize2fs foo.img
    e2fsck -fy foo.img
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

Index: e2fsprogs-1.41.12/resize/resize2fs.c
===================================================================
--- e2fsprogs-1.41.12.orig/resize/resize2fs.c
+++ e2fsprogs-1.41.12/resize/resize2fs.c
@@ -782,6 +782,7 @@ static errcode_t blocks_to_move(ext2_res
 	ext2_filsys 	fs, old_fs;
 	ext2fs_block_bitmap	meta_bmap;
 	__u32		save_incompat_flag;
+	int		flex_bg;
 
 	fs = rfs->new_fs;
 	old_fs = rfs->old_fs;
@@ -899,6 +900,8 @@ static errcode_t blocks_to_move(ext2_res
 	 * gets interesting....
 	 */
 	meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
+	flex_bg = fs->super->s_feature_incompat &
+		EXT4_FEATURE_INCOMPAT_FLEX_BG;
 	/* first reserve all of the existing fs meta blocks */
 	for (i = 0; i < max_groups; i++) {
 		has_super = ext2fs_bg_has_super(fs, i);
@@ -928,18 +931,37 @@ static errcode_t blocks_to_move(ext2_res
 		/*
 		 * Reserve the existing meta blocks that we know
 		 * aren't to be moved.
+		 *
+		 * For flex_bg file systems, in order to avoid
+		 * overwriting fs metadata (especially inode table
+		 * blocks) belonging to a different block group when
+		 * we are relocating the inode tables, we need to
+		 * reserve all existing fs metadata blocks.
 		 */
-		if (fs->group_desc[i].bg_block_bitmap)
+ 		if (ext2fs_block_bitmap_loc(fs, i))
+ 			ext2fs_mark_block_bitmap(rfs->reserve_blocks,
+ 				 ext2fs_block_bitmap_loc(fs, i));
+		else if (flex_bg && i < old_fs->group_desc_count)
 			ext2fs_mark_block_bitmap(rfs->reserve_blocks,
-				 fs->group_desc[i].bg_block_bitmap);
-		if (fs->group_desc[i].bg_inode_bitmap)
+				 ext2fs_block_bitmap_loc(old_fs, i));
+
+ 		if (ext2fs_inode_bitmap_loc(fs, i))
+ 			ext2fs_mark_block_bitmap(rfs->reserve_blocks,
+ 				 ext2fs_inode_bitmap_loc(fs, i));
+		else if (flex_bg && i < old_fs->group_desc_count)
 			ext2fs_mark_block_bitmap(rfs->reserve_blocks,
-				 fs->group_desc[i].bg_inode_bitmap);
-		if (fs->group_desc[i].bg_inode_table)
-			for (blk = fs->group_desc[i].bg_inode_table, j=0;
-			     j < fs->inode_blocks_per_group ; j++, blk++)
+				 ext2fs_inode_bitmap_loc(old_fs, i));
+
+ 		if (ext2fs_inode_table_loc(fs, i))
+ 			for (blk = ext2fs_inode_table_loc(fs, i), j=0;
+ 			     j < fs->inode_blocks_per_group ; j++, blk++)
+ 				ext2fs_mark_block_bitmap(rfs->reserve_blocks,
+ 							 blk);
+		else if (flex_bg && i < old_fs->group_desc_count)
+			for (blk = ext2fs_inode_table_loc(old_fs, i), j=0;
+			     j < old_fs->inode_blocks_per_group ; j++, blk++)
 				ext2fs_mark_block_bitmap(rfs->reserve_blocks,
-							 blk);
+							  blk);
 
 		group_blk += rfs->new_fs->super->s_blocks_per_group;
 	}
commit ddcf1dbff2b8523c2207fbebaa4e5f42880dd2a3
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Dec 29 03:25:10 2012 -0500

    resize2fs: handle bg descriptors which overlap with other bg's metadata
    
    With flex_bg file systems, bg-specific metadata (i.e., bitmaps and the
    inode table blocks) can be located in another block group.  Hence,
    when we grow the number of block group descriptors, we need to check
    if we need to relocate metadata blocks not just for the block group
    where the bgd blocks are located, but in all block groups.
    
    This change fixes the following test case:
    
    rm -f foo.img; touch foo.img
    truncate -s 32G foo.img
    mke2fs -F -t ext4 -E resize=12582912 foo.img
    e2fsck -f foo.img
    truncate -s 256G foo.img
    ./resize2fs foo.img
    e2fsck -fy foo.img
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

Index: e2fsprogs-1.41.12/resize/resize2fs.c
===================================================================
--- e2fsprogs-1.41.12.orig/resize/resize2fs.c
+++ e2fsprogs-1.41.12/resize/resize2fs.c
@@ -743,13 +743,42 @@ static void mark_fs_metablock(ext2_resiz
 	if (IS_BLOCK_BM(fs, group, blk)) {
 		FS_BLOCK_BM(fs, group) = 0;
 		rfs->needed_blocks++;
-	} else if (IS_INODE_BM(fs, group, blk)) {
+		return;
+	}
+	if (IS_INODE_BM(fs, group, blk)) {
 		FS_INODE_BM(fs, group) = 0;
 		rfs->needed_blocks++;
-	} else if (IS_INODE_TB(fs, group, blk)) {
+		return;
+	}
+	if (IS_INODE_TB(fs, group, blk)) {
 		FS_INODE_TB(fs, group) = 0;
 		rfs->needed_blocks++;
-	} else if (EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+		return;
+	}
+
+	if (fs->super->s_feature_incompat & EXT4_FEATURE_INCOMPAT_FLEX_BG) {
+		dgrp_t i;
+
+		for (i=0; i < rfs->old_fs->group_desc_count; i++) {
+			if (IS_BLOCK_BM(fs, i, blk)) {
+				ext2fs_block_bitmap_loc_set(fs, i, 0);
+				rfs->needed_blocks++;
+				return;
+			}
+			if (IS_INODE_BM(fs, i, blk)) {
+				ext2fs_inode_bitmap_loc_set(fs, i, 0);
+				rfs->needed_blocks++;
+				return;
+			}
+			if (IS_INODE_TB(fs, i, blk)) {
+				ext2fs_inode_table_loc_set(fs, i, 0);
+				rfs->needed_blocks++;
+				return;
+			}
+		}
+	}
+
+	if (EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
 					      EXT4_FEATURE_RO_COMPAT_GDT_CSUM) &&
 		   (fs->group_desc[group].bg_flags & EXT2_BG_BLOCK_UNINIT)) {
 		/*
