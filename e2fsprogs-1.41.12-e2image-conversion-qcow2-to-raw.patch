From 92dcfb7692da5c3ed61899c49c0915f889815c45 Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Wed, 18 May 2011 14:20:47 +0200
Subject: [PATCH 3/4] e2image: Support for conversion QCOW2 image into raw

Upstream commit: 92dcfb7692da5c3ed61899c49c0915f889815c45

This commit adds support for converting QCOW2 image created previously
with e2image into raw image. The QCOW2 image is detected automatically,
so there is not new option. Just use following command:

  e2image -r image.qcow image.raw

No that this tool is aimed to quickly convert qcow2 image created with
e2image into raw image. In order to improve speed we are doing some
assumption I believe might not be true for regular qcow2 images. So it
was not tested with regular QCOW2 images and it might not work with
them. The intention of this tool is only convert images previously
created by e2image.

Note that there is nothing special with QCOW2 images created by e2images
and it can be used with tools like qemu-img, or qemu-nbd without any
problems.

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---

Index: e2fsprogs-1.41.12/misc/e2image.8.in
===================================================================
--- e2fsprogs-1.41.12.orig/misc/e2image.8.in
+++ e2fsprogs-1.41.12/misc/e2image.8.in
@@ -131,6 +131,10 @@ the 
 option will prevent analysis of problems related to hash-tree indexed
 directories.
 .PP
+Note that this will work even if you substitute "/dev/hda1" for another raw
+disk image, or QCOW2 image previously created by
+.BR e2image .
+.PP
 .SH QCOW2 IMAGE FILES
 The
 .B \-Q
Index: e2fsprogs-1.41.12/misc/e2image.c
===================================================================
--- e2fsprogs-1.41.12.orig/misc/e2image.c
+++ e2fsprogs-1.41.12/misc/e2image.c
@@ -1216,16 +1216,33 @@ static void install_image(char *device, 
 	exit (0);
 }
 
+static struct ext2_qcow2_hdr *check_qcow2_image(int *fd, char *name)
+{
+
+#ifdef HAVE_OPEN64
+	*fd = open64(name, O_RDONLY, 0600);
+#else
+	*fd = open(name, O_RDONLY, 0600);
+#endif
+	if (*fd < 0)
+		return NULL;
+
+	return qcow2_read_header(*fd);
+}
+
 int main (int argc, char ** argv)
 {
 	int c;
 	errcode_t retval;
 	ext2_filsys fs;
 	char *image_fn;
+	struct ext2_qcow2_hdr *header = NULL;
 	int open_flag = 0;
 	int img_type = 0;
 	int flags = 0;
+	int qcow2_fd = 0;
 	int fd = 0;
+	int ret = 0;
 
 #ifdef ENABLE_NLS
 	setlocale(LC_MESSAGES, "");
@@ -1269,6 +1286,14 @@ int main (int argc, char ** argv)
 		exit (0);
 	}
 
+	if (img_type & E2IMAGE_RAW) {
+		header = check_qcow2_image(&qcow2_fd, device_name);
+		if (header) {
+			flags |= E2IMAGE_IS_QCOW2_FLAG;
+			goto skip_device;
+		}
+	}
+
 	retval = ext2fs_open (device_name, open_flag, 0, 0,
 			      unix_io_manager, &fs);
         if (retval) {
@@ -1278,6 +1303,7 @@ int main (int argc, char ** argv)
 		exit(1);
 	}
 
+skip_device:
 	if (strcmp(image_fn, "-") == 0)
 		fd = 1;
 	else {
@@ -1299,12 +1325,35 @@ int main (int argc, char ** argv)
 		exit(1);
 	}
 
+	if (flags & E2IMAGE_IS_QCOW2_FLAG) {
+		ret = qcow2_write_raw_image(qcow2_fd, fd, header);
+		if (ret) {
+			if (ret == -QCOW_COMPRESSED)
+				fprintf(stderr, "Image (%s) is compressed\n",
+					image_fn);
+			if (ret == -QCOW_ENCRYPTED)
+				fprintf(stderr, "Image (%s) is encrypted\n",
+					image_fn);
+			com_err(program_name, ret,
+				_("while trying to convert qcow2 image"
+				" (%s) into raw image (%s)"),
+				device_name, image_fn);
+		}
+		goto out;
+	}
+
+
 	if (img_type)
 		write_raw_image_file(fs, fd, img_type, flags);
 	else
 		write_image_file(fs, fd);
 
 	ext2fs_close (fs);
+out:
+	if (header)
+		free(header);
+	if (qcow2_fd)
+		close(qcow2_fd);
 	remove_error_table(&et_ext2_error_table);
-	exit (0);
+	return ret;
 }
